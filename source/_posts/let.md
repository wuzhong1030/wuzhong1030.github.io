---
title: let
date: 2018-11-08 10:43:20
tags: javascript
---

### let是否存在变量提升？

<!-- more -->

### 初识let
* let声明的变量是块级作用域的
* 不允许你重复声明一个let变量
* 存在暂时性死区（TDZ），即必须先声明再使用

### 在for循环中的应用
先看看var的现象
```js
for (var i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i)
    }, i * 1000)
}
```
毫无疑问，输入5个5

使用let
```js
for (let i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i)
    }, i * 1000)
}
```
结果是0，1，2，3，4。

### 为什么会这样
1. for (let i = 0; i < 5; i++) 这个语句，会产生一个隐藏的作用域
2. 在每次执行循环体之前，js引擎会会把i在循环体的上下文重新声明一次，并初始化
3. 为什么会有这样的操作？我的理解就是因为let不允许重复声明，所以弄了一个隐形变量来存i

#### var 声明的「创建、初始化和赋值」过程 
```js
function fn(){
  var x = 1
  var y = 2
}
fn()
```
1. js引擎解析代码，fn进入调用栈，创建上下文环境
2. 找出用var声明的变量，加入到词法环境中，值初始化为undefined
3. 执行阶段，把x赋值为1，y赋值为2

这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined

#### function 声明的「创建、初始化和赋值」过程
```js
fn2()
function fn2(){
  console.log(2)
}
```
1. 找到fn声明的函数，加入到词法环境
2. 把函数的引用指向这个fn
3. 执行fn

所以，function 声明会在代码执行之前就「创建、初始化并赋值」

#### let 声明的「创建、初始化和赋值」过程
```js
{
  let x = 1
  x = 2
}
```
1. 找到所有用 let 声明的变量，在环境中「创建」这些变量
2. 开始执行代码（注意现在还没有初始化）
3. 执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）
4. 执行 x = 2，对 x 进行「赋值」
所以，let x 之前使用 x 会报错，因为此时x还没有初始化

### 探究原因-总结
1. let的创建过程被提升了，但是初始化过程没有提升
2. var的创建以及初始化过程都被提升了
3. function的创建，初始化以及赋值过程都被提升

## 结尾
let x = x报错之后，再次let x依然会报错
这个问题说明：如果 let x 的初始化过程失败了，那么
1. x 变量就将永远处于 created 状态
2. 你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）
3. 由于 x 无法被初始化，所以 x 永远处在暂时死区

参考
- [let深入理解---let存在变量提升吗？](https://www.jianshu.com/p/0f49c88cf169)