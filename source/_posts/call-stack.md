---
title: 执行上下文和执行栈
date: 2018-12-04 16:58:23
tags: javascript
---

### 执行上下文的类型
> 当前 javascript 代码解析和执行所创建的抽象环境。

* 全局执行上下文
只有一个全局上下文，在浏览器环境下，全局上下文就是window对象，this指向的是全局对象
* 函数执行上下文
可能有多个，只有在函数被调用的时候才会创建，也就是每次函数被调用的时候都会创建一个属于该函数的执行上下文对象
* eval
指的是在 eval 中运行的代码，极少使用

### 执行栈
也叫 `调用栈`，是一种 LIFO （后进先出）的数据结构，用于存储代码执行期间所创建的执行上下文。
当js引擎执行script标签中的代码，首先进入执行栈的是全局上下文对象，然后遇到函数调用时，引擎会为这个函数创建一个函数执行上下文并push到执行栈的栈顶。
根据LIFO规则，当栈顶的函数执行完毕之后，会执行出栈操作，也就是从当前执行栈的栈顶弹出，上下文控制权会交给当前执行栈的下一个执行上下文。

### 执行上下文的创建
执行上下文分两个阶段创建：1）创建阶段； 2）执行阶段
#### 创建阶段
* LexicalEnvironment（词法环境） 组件被创建
* VariableEnvironment（变量环境） 组件被创建

伪代码
```js
ExecutionContext = {  
  LexicalEnvironment = { ... },   // 词法环境
  VariableEnvironment = { ... },  // 变量环境
}
```

##### 词法环境（Lexical Environment）

词法环境有两个组成部分
1. 环境记录：存储变量和函数声明的实际位置
2. 对外部环境的引用：可以访问其外部词法环境

词法环境有两种类型
1. 全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。
2. 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

##### 变量环境
变量环境也是一个词法环境，在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。

变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。

##### 执行阶段
此阶段，完成对所有变量的分配，最后执行代码。

如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。



