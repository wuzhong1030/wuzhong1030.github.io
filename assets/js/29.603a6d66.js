(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{238:function(t,e,n){"use strict";n.r(e);var o=n(0),r=Object(o.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"react生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期"}},[t._v("#")]),t._v(" React生命周期")]),t._v(" "),n("p",[t._v("\bReact中生命周期是相对于组件来说的，一个组件从被创建到被卸载这一过程，称为生命周期。其中每一个节点，都有及其重要的作用。")]),t._v(" "),n("h2",{attrs:{id:"初次渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初次渲染"}},[t._v("#")]),t._v(" 初次渲染")]),t._v(" "),n("ol",[n("li",[t._v("constructor，指定this，初始化state，绑定函数")]),t._v(" "),n("li",[t._v("componentWillMount()\n在组件挂载之前调用，并且永远都只执行一次，所以如果在这里定义了setState方法之后，页面永远都只会在加载前更新一次。")]),t._v(" "),n("li",[t._v("render()\n必须要有这个函数，因为该方法不会继承父类，需要自己实现，且必须返回一个JSX元素")]),t._v(" "),n("li",[t._v("componentDidMount()\n在第一次渲染后调用，此时组件已经渲染出dom结构，可以通过this.getDOMNode()来进行访问。")])]),t._v(" "),n("h2",{attrs:{id:"二次渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二次渲染"}},[t._v("#")]),t._v(" 二次渲染")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("componentWillReceiveProps(nextProps)\nprops是父组件传递给子组件的。当子组件接受到nextProps时，不管这个props与原来的是否相同都会执行该方法。")])]),t._v(" "),n("li",[n("p",[t._v("shouldComponentUpdate(nextProps, nextState)\nshouldComponentUpdate方法接收一个新的props和state，函数返回一个bool类型数据决定是否更新组件。如果返回false，则不进行更新。如果返回true，则进入下一环节。通常情况下为了优化，我们需要对新的props以及state和原来的数据作对比，如果发生变化。")])]),t._v(" "),n("li",[n("p",[t._v("componentWillUpdate(nextProps, nextState)\n当组件决定继续更新时，会进入componentWillUpdate方法")])]),t._v(" "),n("li",[n("p",[t._v("然后会执行render()")])]),t._v(" "),n("li",[n("p",[t._v("执行完render函数之后执行componentDidUpdata\n除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate")])])]),t._v(" "),n("p",[t._v("当组件需要被卸载的时候，调用 componentWillUnmount 方法，一般在componentDidMount里面注册的事件需要在这里删除。")])])}),[],!1,null,null,null);e.default=r.exports}}]);