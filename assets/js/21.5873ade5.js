(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{231:function(t,e,a){"use strict";a.r(e);var r=a(0),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("angular1.0 和 vue2.0")]),t._v(" "),a("h2",{attrs:{id:"angular"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#angular"}},[t._v("#")]),t._v(" angular")]),t._v(" "),a("p",[t._v("angularJs 实现的双向绑定是通过脏值检查，来比对数据是否有变更，并且只有在以下场景才会进入脏值检查：")]),t._v(" "),a("ul",[a("li",[t._v("DOM事件，用户输入文本，点击按钮等（ng-click）")]),t._v(" "),a("li",[t._v("XMLHttpRequest请求")]),t._v(" "),a("li",[t._v("$timeout，$interval")]),t._v(" "),a("li",[t._v("Location变更")]),t._v(" "),a("li",[t._v("强制$digest() 或 $apply()")])]),t._v(" "),a("h2",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue")]),t._v(" "),a("p",[t._v("vue采用数据劫持并结合发布者-订阅者模式的方式，通过Object.defineProperty()，实现对各个属性的劫持，给每个属性加上 getter() 和 setter() 方法，当数据变动的时候，发布消息给订阅者，触发相应的回调")])])}),[],!1,null,null,null);e.default=v.exports}}]);