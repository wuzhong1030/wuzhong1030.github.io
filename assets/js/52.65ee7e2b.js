(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{261:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"什么是-keep-alive"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-keep-alive"}},[e._v("#")]),e._v(" 什么是 keep-alive")]),e._v(" "),n("p",[e._v("在 HTTP 早期，每发送一个 http 请求都要打开一个 TPC 连接，完成之后便会立即断开这个连接。这个过程中的创建连接会消耗资源和时间，所以重用连接就非常有必要。在后来的 HTTP 1.0 中和 HTTP 1.1，引入了重用连接机制，即 keep-alive 模式，可以有效的减少TCP连接建立次数，在这个模式下，客户端到服务端的连接持久有效，当建立连接之后，如果后续还需要请求，keep-alive 就避免了重新建立连接。")]),e._v(" "),n("p",[e._v("在 HTTP 1.0 中，该模式是默认关闭的，\b需要在 http 请求头中增加 Connection: Keep-Alive，在 HTTP 1.1中，默认是开启的，如需关闭，设置 Connection: close。")]),e._v(" "),n("h2",{attrs:{id:"带来的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#带来的问题"}},[e._v("#")]),e._v(" 带来的问题")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("长时间的TCP连接容易导致系统资源无效占用\n设置 keepalive_timeout，在响应完一个请求之后，会等待一段时间，再关闭这个连接。")])]),e._v(" "),n("li",[n("p",[e._v("如何判断消息内容/长度的大小\n在 keep-alive 模式下，响应完请求后不会立即关闭连接，所以无法知道客户端是否已经接受全部数据")])])]),e._v(" "),n("p",[e._v("使用消息首部字段Conent-Length，这个字段表示实体内容的长度，客户端可以根据这个字段，来判断接受的内容是否完整；如果响应头中没有Conent-Length，这种情况一般返回的是动态内容，因为服务端也不知道返回内容的具体大小，所以无法通过Conent-Length告知客户端，此时服务端会返回 Transfer-Encoding: chunked，在这个模式下，内容会被分段返回。")]),e._v(" "),n("h2",{attrs:{id:"和-websocket-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#和-websocket-的区别"}},[e._v("#")]),e._v(" 和 websocket 的区别")]),e._v(" "),n("p",[e._v("websocket是一个协议，客户端与服务端可以进行全双工通信，即服务端可以向客户端发送消息，客户端也可以向服务端推送消息；而keep-alive是一种模式，这种模式下，发送请求可以重用TCP连接，不需要重新握手创建连接，并且HTTP也不是全双工通信。")])])}),[],!1,null,null,null);t.default=s.exports}}]);