(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{234:function(e,v,t){"use strict";t.r(v);var _=t(0),l=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("webpack 开发搭建环境")]),e._v(" "),t("h2",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),t("ol",[t("li",[e._v("webpack watch mode")]),e._v(" "),t("li",[e._v("webpack-dev-server")]),e._v(" "),t("li",[e._v("express + webpack-hot-middle")])]),e._v(" "),t("p",[e._v("第一种方式并不会产生一个web服务器，只是会实时监听文件的修改，并打包，还是需要我们去手动搭建一个服务器；在命令行输入 webpack -watch 或者 webpack -w(简写)即可启动")]),e._v(" "),t("p",[e._v("第二种方式提供的功能有：")]),e._v(" "),t("ul",[t("li",[e._v("live reloading")]),e._v(" "),t("li",[e._v("路径重定向")]),e._v(" "),t("li",[e._v("支持https")]),e._v(" "),t("li",[e._v("可以在浏览器中显示编译的错误")]),e._v(" "),t("li",[e._v("支持接口代理")]),e._v(" "),t("li",[e._v("模块热更新（不会刷新浏览器，只替换代码更新的部分）")])]),e._v(" "),t("p",[e._v("第三种方式更加灵活，可以使用不同的中间件来提升开发效率，也可以结合实际业务场景对dev-middle进行编码处理，搭建更加符合业务的开发环境，其实第二种方式底层也是依赖express+dev-middle这种方式。")])])}),[],!1,null,null,null);v.default=l.exports}}]);