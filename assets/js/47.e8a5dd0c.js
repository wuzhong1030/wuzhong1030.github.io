(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{254:function(t,a,s){"use strict";s.r(a);var e=s(0),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("Vue 1.0 到 Vue 2.0 的进化，主要是引入了虚拟 DOM 的概念，为了服务端渲染以及跨端渲染奠定了基础。Vue 2.0 发展了很长时间，周边生态非常完善，但是 Vue 2.0 自身还是有一些缺陷，比如对 TypeScript 支持不够友好（Vue 2.0 部分源码用的是 Facebook 的 Flow 写的），底层响应式的缺陷等。而 Vue 3.0 都对这些有了明显的改进。")]),t._v(" "),s("h2",{attrs:{id:"性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),s("h3",{attrs:{id:"包体积的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#包体积的优化"}},[t._v("#")]),t._v(" 包体积的优化")]),t._v(" "),s("p",[t._v("Vue 3.0 利用了 Tree-shaking 技术，只会打包那些引用的功能，没有使用到的 API 在最终打包的时候会被移除。在 Vue 3.0 的 Function-based API，基于函数的 API 会有更好的代码压缩率，因为函数在打包阶段是可以被压缩的（函数名，变量名），而对象或者 class 的属性名和方法名却不可以")]),t._v(" "),s("h3",{attrs:{id:"底层数据响应式的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#底层数据响应式的优化"}},[t._v("#")]),t._v(" 底层数据响应式的优化")]),t._v(" "),s("p",[t._v("Vue 2.0 在底层数据响应式用的是 Object.defineProperty,这个 API 的缺陷在于必须要预先知道需要监听的 key 是什么，所以动态的添加属性和删除属性时就没法监听，而且如果对象层级深，需要递归遍历监听，才可以把每一层对象数据变成响应式的，这必然会造成性能负担。还有一个缺陷是，没法很好的劫持数组，所以 Vue 2.0 里用了比较 hack 的方式，劫持数组的原型方法，以此来侦听数组的改变。\nVue 3.0 利用了 Proxy API 做数据劫持：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("observed "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Proxy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// track")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// trigger")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("p",[t._v("3.0 中用的“懒代理”的模式，并不会在初始化的时候就全部递归侦听，而是在真正访问的时候才会代理。也很好的解决了动态添加/删除属性的问题，同时也支持对数组的侦听，Map、Set、WeakMap 和 WeakSet 这些也都原生支持。")]),t._v(" "),s("h3",{attrs:{id:"编译阶段的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译阶段的优化"}},[t._v("#")]),t._v(" 编译阶段的优化")]),t._v(" "),s("p",[t._v("Vue 2.0 更新渲染粒度是组件级别的，也就是当数据更新的时候，会 diff 整个组件 vnode 树，虽然 2.0 在编译时做了静态节点的优化（给静态节点打上标签，diff 以会直接跳过静态节点的对比），但这远远不够，因为 diff 的过程依然是整个组件 vnode 树，如果一个组件模版只有少量的动态节点，其余大部分都是静态节点，这显然是一种性能浪费。所以结论就是：Vue 2.0 的渲染性能和模版大小有正相关关系，和动态节点数量没有关系。")]),t._v(" "),s("p",[t._v("Vue 3.0 引用了 Block-tree 的概念，在编译阶段，通过对静态模版的分析，给动态节点打上 PatchFlags，生成 Block-tree,在 diff 的时候，可以做到定向更新而非整个树的遍历。所以就做到了：Vue 3.0 的渲染性能和动态节点数量有正相关关系。")]),t._v(" "),s("h2",{attrs:{id:"语法优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法优化"}},[t._v("#")]),t._v(" 语法优化")]),t._v(" "),s("p",[t._v("Vue 3.0 提供了 Composition API，相较于 2.0 的 Options API，这两者在 3.0 中是共存的，简单的组件依然可以使用 Options API 的方式来组织代码。")]),t._v(" "),s("h3",{attrs:{id:"更好的逻辑组织"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更好的逻辑组织"}},[t._v("#")]),t._v(" 更好的逻辑组织")]),t._v(" "),s("p",[t._v("Composition API 的存在是为了提供更强的组织代码的能力，可以使得一个功能逻辑能够比较集中的写在一个地方，相较于 Options API，因为多个选项的关系，会导致代码逻辑比较分散。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ff982e039d64834b03dbb5d50a37187~tplv-k3u1fbpfcp-watermark.image",alt:"对比"}})]),t._v(" "),s("h3",{attrs:{id:"更好的逻辑复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更好的逻辑复用"}},[t._v("#")]),t._v(" 更好的逻辑复用")]),t._v(" "),s("p",[t._v("2.0 的逻辑复用主要使用 Mixins，这个东西的问题比较大，容易导致命名冲突，而且会数据来源不清晰，所以在 3.0 中这个被干掉了。而 Composition API 就有优势，因为它本质就是一个函数，因为是函数，所以也就对类型推导支持的更好。")]),t._v(" "),s("h2",{attrs:{id:"源码管理优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源码管理优化"}},[t._v("#")]),t._v(" 源码管理优化")]),t._v(" "),s("p",[t._v("Vue 3.0 采用 monorepo + TypeScript 的方式管理和组织代码，目的就是提升源码可维护性。")]),t._v(" "),s("h3",{attrs:{id:"更好的源码管理方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更好的源码管理方式"}},[t._v("#")]),t._v(" 更好的源码管理方式")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba4ce02144c4efd9b034d4084fd0604~tplv-k3u1fbpfcp-watermark.image",alt:"monorepo"}})]),t._v(" "),s("p",[t._v("通过 monorepo 的方式维护，根据功能不同分别拆分到不同的 packages 下的子目录。每个子目录都有各自的 API，类型定义和测试。这样可以模块拆分更加细化，职责划分更明确，阅读性也更高。")]),t._v(" "),s("h3",{attrs:{id:"更好的-typescript-支持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更好的-typescript-支持"}},[t._v("#")]),t._v(" 更好的 TypeScript 支持")]),t._v(" "),s("p",[t._v("Vue 3.0 使用了 TypeScript 进行重构，提供了更好的类型检查，可以做到比 Flow 更好的类型推导。")])])}),[],!1,null,null,null);a.default=r.exports}}]);